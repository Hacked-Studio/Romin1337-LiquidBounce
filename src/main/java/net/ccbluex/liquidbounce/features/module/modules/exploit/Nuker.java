package net.ccbluex.liquidbounce.features.module.modules.exploit;

import net.ccbluex.liquidbounce.event.EventTarget;
import net.ccbluex.liquidbounce.event.UpdateEvent;
import net.ccbluex.liquidbounce.features.module.Module;
import net.ccbluex.liquidbounce.features.module.ModuleCategory;
import net.ccbluex.liquidbounce.features.module.ModuleInfo;
import net.ccbluex.liquidbounce.utils.Rotation;
import net.ccbluex.liquidbounce.utils.RotationUtils;
import net.ccbluex.liquidbounce.utils.timer.MSTimer;
import net.ccbluex.liquidbounce.value.BoolValue;
import net.ccbluex.liquidbounce.value.IntegerValue;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.entity.projectile.EntitySnowball;
import net.minecraft.item.ItemStack;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;

@ModuleInfo(name = "Nucker",description = "Spid",category = ModuleCategory.WORLD)
public final class Nuker extends Module {
    private final MSTimer timer = new MSTimer();
    public IntegerValue radius = new IntegerValue("Horizontal Radius", 3, 0, 50);
    public IntegerValue height = new IntegerValue("Height Radius", 1, 0, 50);
    public BoolValue silent = new BoolValue("Silent", true);
    private boolean isRunning;
    public BoolValue autoTool = new BoolValue("AutoTool", true);
    private int posX, posY, posZ;
    
    @EventTarget
    public void onUpdate(UpdateEvent e) {
        this.isRunning = false;
        int radius = this.radius.get().intValue();
        int height = this.height.get().intValue();

        for (int y = height; y >= -height; --y) {
            for (int x = -radius; x < radius; ++x) {
                for (int z = -radius; z < radius; ++z) {
                    this.posX = (int) Math.floor(mc.thePlayer.posX) + x;
                    this.posY = (int) Math.floor(mc.thePlayer.posY) + y;
                    this.posZ = (int) Math.floor(mc.thePlayer.posZ) + z;
                    if (mc.thePlayer.getDistanceSq(mc.thePlayer.posX + (double) x, mc.thePlayer.posY + (double) y, mc.thePlayer.posZ + (double) z) <= 16.0D) {
                        Block block = (Block) mc.theWorld.getBlockState(new BlockPos(this.posX, this.posY, this.posZ));
                        boolean blockChecks = timer.hasTimePassed(50l);
                        blockChecks = blockChecks && canSeeBlock(this.posX + 0.5F, this.posY + 0.9f, this.posZ + 0.5F) && !(block instanceof BlockAir);
                        blockChecks = blockChecks && (block.getBlockHardness(mc.theWorld, BlockPos.ORIGIN) != -1.0F || mc.playerController.isInCreativeMode());
                        if (blockChecks) {
                            this.isRunning = true;
                            Rotation angles = RotationUtils.getRotationFromPosition(this.posX + 0.5, this.posZ + 0.5, this.posY + 0.5);
                            final float yaw = angles.getYaw();
                            final float pitch = angles.getPitch();
                            if (silent.get()) {
                                mc.thePlayer.rotationYawHead = yaw;
                                mc.thePlayer.prevRotationYawHead = yaw;
                                mc.thePlayer.renderYawOffset = yaw;
                                mc.thePlayer.prevRenderYawOffset = yaw;
                            } else {
                                mc.thePlayer.rotationYaw = yaw;
                                mc.thePlayer.rotationPitch = pitch;
                            }
                            return;
                        }
                    }
                }
            }
        }
    }


    @Override
    public void onDisable() {
        super.onDisable();
        isRunning = false;
        posX = posY = posZ = 0;
    }

    @EventTarget
    public void onMontion(UpdateEvent e) {
        if (this.isRunning) {
            final BlockPos blockPos = new BlockPos(this.posX, this.posY, this.posZ);

            if (autoTool.get()) {
                float strength = 1.0f;
                int bestItemIndex = -1;
                for (int i = 0; i < 8; i++) {
                    ItemStack itemStack = mc.thePlayer.inventory.mainInventory[i];
                    if (itemStack == null) continue;
                    bestItemIndex = i;
                }
                if (bestItemIndex != -1 && mc.thePlayer.inventory.currentItem != bestItemIndex) {
                    mc.thePlayer.inventory.currentItem = bestItemIndex;
                }
            }

            mc.thePlayer.swingItem();
            mc.playerController.onPlayerDamageBlock(blockPos, getFacing(blockPos));

            if (mc.playerController.curBlockDamageMP >= 1.0D)
                timer.reset();

        }
    }

    public boolean canSeeBlock(final float n, final float n2, final float n3) {
        return this.getFacing(new BlockPos(n, n2, n3)) != null;
    }

    public EnumFacing getFacing(final BlockPos blockPos) {
        EnumFacing[] array;
        for (int length = (array = new EnumFacing[] { EnumFacing.UP, EnumFacing.NORTH, EnumFacing.EAST, EnumFacing.SOUTH, EnumFacing.WEST, EnumFacing.DOWN }).length, i = 0; i < length; ++i) {
            final EnumFacing enumFacing = array[i];
            final EntitySnowball entitySnowball = new EntitySnowball(mc.theWorld);
            entitySnowball.posX = blockPos.getX() + 0.5;
            entitySnowball.posY = blockPos.getY() + 0.5;
            entitySnowball.posZ = blockPos.getZ() + 0.5;
            entitySnowball.posX += enumFacing.getDirectionVec().getX() * 0.5;
            entitySnowball.posY += enumFacing.getDirectionVec().getY() * 0.5;
            entitySnowball.posZ += enumFacing.getDirectionVec().getZ() * 0.5;
            if (mc.thePlayer.canEntityBeSeen(entitySnowball)) {
                return enumFacing;
            }
        }
        return null;
    }
}
